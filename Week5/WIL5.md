# 5주차

****목표****

**객체지향 패러다임과 객체, 그리고 객체 지향 4 대 특성에 대하여 알아봅시다. 그리고 오버라이딩 vs 오버로딩의 차이점을 알아보고, call by value와 call by reference를 알아봅시다.**

**학습 범위 : 스프링 입문을 위한 자바 객체 지향의 원리와 이해 챕터 3**

---

구조적 프로그래밍 언어에서 가장 중요한 것은 함수.

**함수**는 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 것.

## 객체 지향의 4대 특성

*“캡! 상추다”*

- **캡슐화(정보 은닉), 상속(재사용+확장), 추상화(모델링), 다형성(사용 편의)**

### 추상화는 모델링이다

- **추상** : 여러 가지 사물이나 개념에서 **공통되는 특성**이나 속성 따위를 추출하여 파악하는 작용
- **객체** : **세상에 존재하는 유일무일한 사물**
- **클래스** : **분류**, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념

- OOP의 추상화는 모델링이다.
- 클래스 : 객체 = 펭귄 : 뽀로로
- 클래스 설계에서 추상화가 사용된다.
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.
- 객체 지향에서 추상화의 결과는 클래스다.
- 추상화 = 모델링 = 자바의 class 키워드

- 객체가 생성돼야만 속성의 값을 저장하기 위한 메모리 공간이 스태틱 영역이 아닌 힙 영역에 할당된다.
- 클래스 멤버와 객체 멤버를 구분하는 자바 키워드는 static이다.
- 자바에서는 포인터가 객체 참조 변수에 할당된다.
- 객체 참조 변수가 더이상 힙 영역에 존재하는 객체를 참조하지 않으면 가비지 컬렉터가 쓰레기로 인지하고 수거해 간다.
- 스태틱 영역에 올라간 정보는 main() 메서드가 시작되기 전에 올라가서 main() 메서드가 종료된 후에 내려올 정도로 스태틱 영역에 단단히 고정돼 있기 때문에 스태틱 영역이라고 한다.

### 클래스 멤버 vs. 객체 멤버

클래스 멤버 = static 멤버 = 정적 멤버

객체 멤버 = 인스턴스 멤버

- 같은 클래스의 모든 객체가 같은 값을 가지고 있다면 그 값을 클래스에 저장
    
    —>해당 속성 앞에 static 키워드 붙여서 클래스 멤버로 활용
    
    - `객체참조변수.속성`  , `클래스명.속성` 으로 접근 가능
        
        ex) `jerry.tailCount`  ,   `Mouse.tailCount`
        
- **클래스 멤버 속성** : static 키워드가 붙은 속성
- **객체 멤버 속성** : static 키워드가 안 붙은 속성
    
    —> 같은 기준으로 **클래스 멤버 메서드**, **객체 멤버 메서드** 분류
    

- main() 메서드는 항상 static 키워드가 붙어 있다. 클래스 멤버 메서드이기 때문.
- 클래스 멤버들은 T 메모리의 static 영역에 상주하게 되므로 **static(정적)멤버**라고도 한다.
- 정적 멤버 속성은 해당 클래스의 모든 객체들이 같은 값을 가질 때 사용
    - ex) 승용차 클래스의 바퀴 개수
- 정적 멤버들은 객체의 존재 여부와 관계없이 쓸 수 있다.
- **정적 멤버 사용 예시** :
    - main() 메서드의 논리를 함수로 분할해서 사용하는 경우
    - 정적 변수에 대한 접근자 메서드(getter)와 설정자 메서드(setter)로 사용하는 경우
    - 클래스의 인스턴스를 만들지 않고 사용하는 유틸리성 메서드

- 클래스 속성, 객체 속성은 자동으로 초기화된다.

### 상속: 재사용+확장

상속은 부모-자식 관계와 다르다. 계층도X, 

“동물 - 포유류 - 고래” 방식. 동물은 포유류의 부모가 아니다.

—> “포유류는 동물의 **특성을 확장**했다”

**객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성들 상속)하고 거기에 더해 필요한 특성을 추가(확장)해서 사용할 수 있다는 의미이다.**

- 상위 클래스 쪽으로 갈수록 추상화, 일반화. 하위 클래스 쪽으로 갈수록 구체화, 특수화
- 하위 클래스는 상위 클래스이다. 포유류는 동물이다.
- 자바에는 inheritance(상속) 키워드는 없고 대신 **extends(확장)**이 존재한다.
- 클래스명은 클래스답게, 객체 참조 변수명은 객체답게 지어야 한다.
    - **클래스**명은 **분류**스럽게, **객체 참조 변수**명은 **유일무이한 사물**처럼 작명해야 한다.
    - Bird - aBird, theBird, 까마귀
- 클래스 상속 구조에서 최상위 클래스는 **Object**이다.
    - 모든 클래스는 Object의 특성을 물려받는다.
    - 그래서 어떤 클래스의 인스턴스이든 상관없이 toString() 에서드 사용 가능

- 하위 클래스 is a kind of 상위 클래스
    - 펭귄 is a kind of 조류 —> 펭귄은 조류의 한 분류이다.
- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

### 다중 상속X —> 인터페이스

자바는 다중 상속을 지원하지 않는다.

다이아몬드 문제 등 득실에서 실이 더 많아서. 대신 인터페이스를 도입함

- 인터페이스는 be able to, 즉 “무엇을 할 수 있는” 형태로 만드는 것이 좋다.
    - ex) Serializable, Cloneable, Comparable, Runnable 인터페이스
- **상위 클래스는 하위 클래스에세 물려줄 특성이 많을수록 좋다**. (LSP 리스코프 치환 원칙)
- **인터페이스는 구현을 강제할 메서드가 적을수록 좋다.** (ISP 인터페이스 분할 원칙)

```java
public class 고래 extends 포유류 implements 헤엄칠 수 있는 {}
```

- **하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.**
    - 모든 클래스의 최상위 클래스인 Object 클래스의 인스턴스도 함께 생성된다.

### 다형성 : 사용편의성

- **오버라이딩(overriding)** : 같은 메서드 이름, **같은 인자 목록**으로 상위 클래스의 메서드를 **재정의**
    
    —> 🏍️ 올라타기.
    
- **오버로딩(overloading)** : 같은 메서드 이름, **다른 인자 목록**으로 다수의 메서드를 **중복 정의**
    
    —> 🚚 적재하기.
    

```java
// 오버라이딩
public void hello() {System.out.printf("안녕")}

// 오버로딩
public void hello(String name) {System.out.printf("안녕, 난 %s라고 해", name)}
```

- 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다.
- 자바5에서 추가된 **제네릭**을 사용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다.
- 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공하고, 다형성이 사용편의성을 준다.

### 캡슐화: 정보 은닉

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- **정적 멤버**는 `**클래스명**.정적멤버` 형식으로 접근하는 것을 권장한다.

### 참조 변수의 복사

- **기본 자료형 변수를 복사**하는 경우  **Call By Value(값에 의한 호출)**에 의해 값이 복사되고, 2개의 변수를 서로에게 영향을 주지 않는다.
- 기본 자료형이 아닌 객체를 저장하고 있는 객체 참조 변수를 복사하는 경우 **Call By Reference(주소에 의한 호출)**

<aside>
📎 .

- call by reference
    
    인자로 받은 값을 복사하여 처리
    
- call by reference
인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다.

 참고자료)    [https://devlog-wjdrbs96.tistory.com/44](https://devlog-wjdrbs96.tistory.com/44)

</aside>